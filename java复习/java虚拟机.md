**1.前言**

- java虚拟机屏蔽了与具体操作系统有关的信息，使得编译器只要生成在虚拟机上可运行的字节码。
- JDK--java程序开发的最小环境（包含了JRE，同时还包含了编译java源码的编译器javac，还包含了很多java程序调试和分析的工具：jconsole，jvisualvm等工具软件，还包含了java程序编写所需的文档和demo例子程序。）[百度知道](https://zhidao.baidu.com/question/55791862.html)
- JRE--java程序运行的最小环境（包含了java虚拟机，java基础类库）
- 所以说java程序可以`一次编译到处运行`是指在安装有jre/jdk的客户端运行，实习跨平台编译
- JDK自带的虚拟机为HotSpot,使用`java -version`查看

**2.内存模型（JMM）**

- JVM内部定义了程序在运行时需要的内存区域。内存区域分为主内存和工作内存。主内存是指物理机的实际内存；工作内存按作用又分为线程独享区 和线程共享区。
- JMM规定所有的变量都存储在主内存仲，每条线程还有自己的工作内存，工作内存保存了自主内存的副本和使用到的变量。
- 线程对变量的所有操作（读写）都必须在工作内存中进行，而不能直接读写主内存中的变量，不同线程之间也不能直接访问对方工作内存中的变量
- 线程间的变量传递需要通过主内存来完成。

***2.1线程独享区***

- 虚拟机栈，方法执行会创建栈帧，用于存储局部变量·操作数栈·动态链接·方法出口等
- 本地方法栈
- 程序计数器，时线程执行的字节码的行号指示器，相当于一条条指令

***2.2线程共享区***

- 堆，用于存放对象实例，是所有内存区最大的一块。里面还被划分成--新生代和老年代[1:2],而且新生代会分得再精致点--Eden空间·From Survivor(S0)·ToSurvivor(S1)  [8:1:1]。这样可以更快滴分配内存
- 方法区，存放加载的类信息，常量池，静态变量

***2.3直接内存***

- 即主内存，不是虚拟机运行时数据区的一部分。但这部分内存会被频繁使用，也会导致OutOfMemoryError异常
- NIO可以直接使用Native含上诉直接分配堆外内存，能显著提高性能，避免再java堆和Native堆之间复制数据

***2.4垃圾回收***

- 回收没有用的对象
- 确定需要回收的对象
- 怎样区回收
- 适用的场景


