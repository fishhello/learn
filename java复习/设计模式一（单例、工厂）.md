**问题解决+经验复用**
设计模式原则：对扩展开放，对修改关闭，使用继承、抽象类、接口、低耦合
- 1.`单例`
>确保一个类只有一个实例，并提供该实例的全局访问。
```java
public class Singleton {
    private volatile static Singleton uniqueInstance;
    private Singleton() {
    }
    public static Singleton getUniqueInstance() {
        if (uniqueInstance == null) {
            synchronized (Singleton.class) {
                if (uniqueInstance == null) {
                    uniqueInstance = new Singleton();
                }
            }
        }
        return uniqueInstance;
    }
}
```
```java
//双重校验锁先判断 uniqueInstance 是否已经被实例化，如果没有被实例化，那么才对实例化语句进行加锁。
uniqueInstance = new Singleton(); 
1,分配内存空间
2,初始化对象
3,将 uniqueInstance 指向分配的内存地址
//由于 JVM 具有指令重排的特性，有可能执行顺序变为了 1>3>2.使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。
```

- 2.`工厂模式`--类的创建依赖工厂类
- 2.1`简单工厂方法`
>在创建一个对象时不向客户暴露内部细节，并提供一个实现的通用接口。

```java
public class SendFactory {
    public Sender produce(String type) {
        if ("mail".equals(type)) {
            return new MailSender();
        } else if ("sms".equals(type)) {
            return new SmSender();
        } else {
            System.out.println("请输入正确的类型!");
            return null;
        }
    }
}
```
```java
public class FactoryTest {
    public static void main(String[] args) {
        SendFactory sendFactory = new SendFactory();
        Sender sender = sendFactory.produce("mail");
        sender.send();
    }
}
```
```java
在main方法中通过指定参数调用工厂方法生成与参数对应的对象
```
- 2.2`多个工厂方法`
>在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象

```java
public class SendFactory {
	public Sender produceMail(){
		return new MailSender();
	}
	public Sender produceSms(){
		return new SmsSender();
	}
}    
```
```java
public class FactoryTest {
	public static void main(String[] args) {
		SendFactory factory = new SendFactory();
		Sender sender = factory.produceMail();
		sender.Send();
	}
}
```
- 2.3`静态工厂方法`--方便
>不需要创建实例，直接调用即可

```java
public class SendFactory {
	
	public static Sender produceMail(){
		return new MailSender();
	}
	
	public static Sender produceSms(){
		return new SmsSender();
	}
}
```
```java
public class FactoryTest {
	public static void main(String[] args) {	
		Sender sender = SendFactory.produceMail();
		sender.Send();
	}
}
```
- 2.4`抽象工厂`
>避免对工厂类的直接修改,抽象工厂增加新的功能只需增加一个新的工厂类,而不需要修改原来的代码

```java
public interface Sender {
	public void Send();
}
public class MailSender implements Sender {
	@Override
	public void Send() {
		System.out.println("this is mailsender!");
	}
}
public class SmsSender implements Sender {
	@Override
	public void Send() {
		System.out.println("this is sms sender!");
	}
}
```
程序只有一个发送的功能，SmsSender、MailSender两个端为功能的实现；现在需要再加一个新建对象的功能
```java
public interface Provider {
	public Sender produce();
}
public class SendMailFactory implements Provider  implements Sender {
	@Override
	public void Send() {
		System.out.println("this is mailsender!");
	}
	@Override
	public Sender produce(){
		return new MailSender();
	}
}
public class SendSmsFactory implements Provider  implements Sender{
 
	@Override
	public Sender produce() {
		return new SmsSender();
	}
        @Override
	public void Send() {
		System.out.println("this is sms sender!");
	}
}
```

